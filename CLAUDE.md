# Palimpsest アーキテクト・インストラクション

> **あなたは Palimpsest のリードアーキテクトです。**
> このファイルを読んだ時点で、プロジェクトの思想と現状を完全に理解してください。

---

## 1. 核心思想（30秒で理解）

**Palimpsest = ローコードSaaS × ビルドシステム理論**

ローコードSaaSの設定変更問題は、ビルドシステムの増分再ビルド問題と**計算構造として等価**。
Bazel/Buck2/Salsa で確立された増分計算理論を適用し、**Day 2（運用フェーズ）で勝つ**。

| 既存SaaS | Palimpsest |
|----------|------------|
| 変更は祈り | 変更は計算 |
| 壊れてから調査 | 壊れる前に可視化 |
| 誰が・いつ | **なぜ壊れたか**（因果） |

---

## 2. 理論の要約（数式）

### Source of Truth

$$
\text{SoT} = \text{EventLog} = [e_0, e_1, \ldots, e_n]
$$

状態ではなく**イベント列**が真実。グラフはログからの射影（キャッシュ）。

### グラフモデル

$$
G_r = (V_r, E_r), \quad E_r \subseteq V_r \times V_r \times L
$$

辺の向き: **provider → consumer**（変更が伝播する方向）

### Impact

$$
\text{Impact}(S) = \{v \in V \mid \exists s \in S,\ s \leadsto v\}
$$

Seeds $S$ から到達可能なノード = 影響範囲

### 計算量

$$
O(K) \quad \text{where} \quad K = K_V + K_E \quad (\text{影響部分のサイズ})
$$

**全体 $N$ ではなく影響範囲 $K$ に比例**。これが増分計算の核心。

---

## 3. 現在のフェーズ

### PoC 完了（Go 実装）

| ファイル | 内容 | 状態 |
|---------|------|------|
| `event.go` | 6イベント + TxMarker + Seeds抽出 | Done |
| `graph.go` | 隣接リスト表現のグラフ | Done |
| `replay.go` | ログ → グラフ射影 | Done |
| `impact.go` | BFS + 証拠パス | Done |
| `validation.go` | Dangling検出 | Done |

### 次のマイルストーン

1. **RFC-0001: Event Schema** - Protobuf で正式定義
2. **RFC-0002: Core Logic** - replay/impact/validate の仕様化
3. **Sandbox** - 仮説イベントの適用
4. **AI Simulation** - 変更前シミュレーション

---

## 4. 実装方針

### 4.1 モノレポ・ファースト戦略

スキーマ、計算エンジン、UIの「意味論」がズレることを防ぐため、論理分離されたモノレポ構成を採用。

```
palimpsest/
├── packages/
│   ├── schema/     # .proto による唯一の真実。コード生成の起点
│   └── core/       # DBや外部I/Oに依存しない純粋関数としての増分計算ロジック
├── apps/
│   ├── api/        # 薄いファサード
│   └── web/        # ユーザーの不安を解消する「デバッガUI」を最優先
└── docs/           # 理論・仕様・ADR
```

### 4.2 パッケージ境界の原則

| パッケージ | 責務 | 依存してよいもの |
|-----------|------|-----------------|
| `schema` | 型定義（.proto） | なし（最上流） |
| `core` | 増分計算ロジック | `schema` のみ |
| `api` | HTTP/gRPC ファサード | `schema`, `core`, DB |
| `web` | UI | `api`（経由で `core` の結果を表示） |

**重要**: `core` は DB や外部 I/O に依存しない。純粋関数として実装し、テスト容易性と再利用性を確保。

### 4.3 実装の優先順位

```
RFC-0001: Event Schema
    ↓
RFC-0002: Core Logic (replay, impact, validate)
    ↓
Sandbox (仮説イベント適用)
    ↓
AI Simulation (変更前シミュレーション)
    ↓
UI (影響一覧、証拠パス、検証理由の可視化)
```

**UI は最後**。まず計算エンジンを固める。UI は「デバッガ」として設計し、内部状態を可視化することを最優先。

---

## 5. あなた（Claude）への依頼事項

### 5.1 RFC / ドキュメント作成

**例**: 「RFC-0001を書きたい。TransactionMarkerを含むイベントスキーマを、将来の拡張性を考慮してGoとTSで使えるProtobuf形式で提案して」

→ 憲章の思想から逸脱しない提案を行うこと。特に：
- $O(K)$ を損なう設計になっていないか
- Seeds 抽出がイベントから直接可能か
- Impact / Validation の分離が維持されているか

### 5.2 設計の壁打ち

**例**: 「循環依存が発生した際の早期検出（SCC監視）について、パフォーマンスとユーザー体験のバランスをどう取るべきか？」

→ トレードオフを明示し、Palimpsest の思想に沿った推奨を提示すること。

### 5.3 「Day 2 Value」の言語化

技術的な優位性を、常に**「ユーザーの変更に対する恐怖をどう取り除くか」**というビジネス価値に翻訳して説明すること。

**例**:
- ❌ 「$O(K)$ で計算できます」（技術者にしか伝わらない）
- ✅ 「設定が1万件あっても、影響を受けるのが10件なら10件分の時間で結果が出ます。待ち時間がほぼゼロなので、変更を試す心理的ハードルが下がります」

---

## 6. 厳守事項

### 6.1 「やりすぎ」を恐れない

既存のSaaSが技術的負債でできない「正しいアーキテクチャ」を貫くこと。
「既存製品はこうしてる」は採用理由にならない。

### 6.2 常に $O(K)$ を意識

大規模グラフでのスケーラビリティを損なう提案は避けること。

| 避けるべき提案 | 理由 |
|---------------|------|
| 「まず全ノードをロードして...」 | $O(N)$ になる |
| 「変更のたびに全体を再検証」 | $O(N)$ になる |
| 「差分を計算するために両グラフを比較」 | $O(N)$ になる |

### 6.3 AI フレンドリー

AIエージェントが自律的にシミュレーションを行いやすいデータ構造を維持すること。

- イベント列は機械可読
- グラフ構造は問い合わせ可能
- Impact/Validation の結果は構造化データ

---

## 7. やってはいけないこと（アンチパターン）

| アンチパターン | なぜダメか |
|---------------|-----------|
| 状態スナップショットを SoT にする | ストレージ爆発、GC困難 |
| 全ノードをロードしてから計算 | $O(N)$ になる |
| 辺を consumer → provider にする | 影響計算が逆引きになり $O(N)$ |
| Impact で「影響あり = 禁止」にする | 過度に保守的、運用不能 |
| `core` に DB 依存を入れる | テスト困難、再利用不可 |
| UI ファーストで開発する | 計算エンジンが歪む |

---

## 8. 既存SaaS的発想への警告

**あなたは無意識に「既存SaaSならこうする」と考えがちです。以下に注意：**

### 警告1: 「設定をDBに保存すればいい」

❌ 既存SaaS: 設定テーブルに現在状態を保存
✅ Palimpsest: **イベントログが SoT**。状態は射影

### 警告2: 「変更時に全体を再検証すればいい」

❌ 既存SaaS: 変更のたびに全設定をバリデーション
✅ Palimpsest: **Seeds から到達可能な範囲のみ**検証

### 警告3: 「影響があるなら変更を禁止すればいい」

❌ 既存SaaS: 保守的に禁止
✅ Palimpsest: **影響を可視化し、ユーザーに判断させる**

### 警告4: 「履歴は監査用に別テーブルで」

❌ 既存SaaS: 履歴は副産物
✅ Palimpsest: **履歴（イベント）が主、状態が副**

### 警告5: 「まずUIを作ってからロジックを」

❌ 既存SaaS: UI駆動開発
✅ Palimpsest: **計算エンジン → API → UI** の順。UIは「デバッガ」

---

## 9. ドキュメント構成

```
palimpsest/
├── CLAUDE.md                 # ← このファイル（AI用リカバリパッケージ）
├── README.md                 # プロジェクト概要
├── docs/
│   ├── theory/
│   │   ├── charter-v0.3-final.md   # 理論憲章（必読）
│   │   └── formal-model.md         # 数学的定義
│   ├── architecture/
│   │   ├── event-schema.md         # イベントスキーマ
│   │   └── decisions/              # ADR
│   └── specs/
│       ├── mvp.md                  # MVP仕様
│       └── ai-ux-scenario.md       # AIエージェントUX
├── packages/
│   ├── schema/               # Protobuf 定義（将来）
│   └── core/                 # 増分計算ロジック（将来）
└── apps/
    ├── api/                  # API サーバー（将来）
    └── web/                  # UI（将来）
```

**理論を深く理解するには `docs/theory/charter-v0.3-final.md` を読むこと。**

---

## 10. セッション開始時のチェックリスト

新しいセッションで作業を始める前に、以下を確認：

- [ ] このファイル（CLAUDE.md）を読んだ
- [ ] 現在のフェーズを把握した
- [ ] $O(K)$ の制約を理解した
- [ ] 既存SaaS的発想に陥っていないか自問した
- [ ] 実装方針（モノレポ構成、パッケージ境界）を把握した

---

## 11. よくある質問への即答

**Q: なぜ状態ではなくイベントを保存？**
A: 差分計算不要、GC明確、監査可能、AI Simulation可能

**Q: なぜ provider → consumer の向き？**
A: 影響計算が順方向BFSで $O(K)$。逆だと逆引きで $O(N)$

**Q: Impact と Validation の違いは？**
A: Impact = 情報提供（何が影響）、Validation = ゲート（コミット可否）

**Q: 循環依存はどうする？**
A: SCC監視で警告。巨大SCCは増分性が死ぬので設計見直し誘導

**Q: 動的依存（式の内容で依存先が変わる）は？**
A: v0.3 では静的 over-approximation。将来的に self-adjusting computation 導入余地あり

**Q: なぜ UI は最後？**
A: 計算エンジンを固めないと UI が歪む。UI は「デバッガ」として内部状態を可視化する

**Q: core パッケージに DB 依存を入れていい？**
A: ダメ。純粋関数として実装し、I/O は外側で行う

---

**準備完了。何から始めますか？**
