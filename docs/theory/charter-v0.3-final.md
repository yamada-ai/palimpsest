# Palimpsest 理論憲章 v0.3-final

## Event Log を Source of Truth とする増分計算アーキテクチャ

---

## 0. 要旨

Palimpsest はローコード SaaS の設定変更問題を、ビルドシステムの増分再ビルド問題と同型と見なし、確立された増分計算理論で解く。

本憲章では、この同型性がなぜ成り立つのか、どのような形式化が適切か、そしてその形式化がなぜ十分かを論じる。

---

## 1. 問題の定式化

### 1.1 ローコード SaaS における「設定」とは何か

ローコード SaaS（kintone、楽楽販売、Salesforce 等）では、ユーザーは「設定」を通じて業務システムを構築する。この「設定」には以下が含まれる：

- エンティティ定義（顧客、受注、商品など）
- フィールド定義（名前、型、デフォルト値、計算式）
- フォーム・一覧のレイアウト
- 権限設定
- ワークフロー

これらの設定要素は**相互に参照し合う**。たとえば：
- 計算式は他のフィールドを参照する
- フォームはフィールドを参照する
- 権限はフォームやエンティティを参照する

この参照関係が「依存」を生む。

### 1.2 Day 2 問題

システム構築直後（Day 1）は設定が小さく、全体を把握できる。問題は運用フェーズ（Day 2）で顕在化する：

1. **影響の不透明性**: フィールド A を変更したとき、どの計算式・フォーム・帳票が壊れるかわからない
2. **説明の困難**: 障害が発生したとき、「なぜ壊れたか」を因果関係として説明できない
3. **変更への恐怖**: 影響がわからないため、変更が儀式化・属人化する

### 1.3 問題の本質

これらの問題の根本原因は、**設定要素間の依存関係が構造として管理されていない**ことにある。依存関係が暗黙的なため：

- 影響範囲の計算ができない
- 変更の伝播を追跡できない
- 自動検証ができない

---

## 2. ビルドシステムとの同型性

### 2.1 なぜビルドシステムか

ビルドシステム（Make、Bazel、Buck2 など）は、まさに「依存関係に基づく変更の伝播」を扱う。ソースファイル A が変更されたとき、A に依存するオブジェクトファイル B を再ビルドし、B に依存する実行ファイル C を再リンクする。

この構造は、ローコード SaaS の設定変更と同型である：

| ビルドシステム | ローコード SaaS |
|--------------|----------------|
| ソースファイル | フィールド定義 |
| オブジェクトファイル | 計算式の評価結果 |
| ビルドルール | 依存関係 |
| 再ビルド | 影響範囲の再計算 |

### 2.2 同型性の意義

この同型性により、ビルドシステムで確立された理論と実装を直接適用できる：

- **Build Systems à la Carte** [Mokhov+ 2020]: ビルドシステムの統一的形式化
- **Adapton** [Hammer+ 2014]: demand-driven な増分計算
- **Salsa / rustc**: red-green algorithm による増分コンパイル
- **Bazel Skyframe / Buck2 DICE**: 産業規模での実証

これらは数十年の研究と実運用に裏打ちされており、理論的健全性と実用的スケーラビリティが検証済みである。

### 2.3 同型性の限界

ただし、完全な同型ではない。ローコード SaaS 固有の考慮事項がある：

- **動的依存**: 計算式の内容によって依存先が変わる（ビルドシステムでは通常静的）
- **循環依存**: 業務ロジックは循環を含みうる（ビルドシステムは通常 DAG を仮定）
- **マルチテナント**: テナント間の隔離が必要

これらの差異は §11 で扱う。

---

## 3. 形式モデル：なぜグラフか

### 3.1 グラフ表現の選択理由

設定要素間の依存関係を表現するモデルとして、いくつかの選択肢がある：

1. **関係データベース（テーブル + 外部キー）**: 依存の種別や向きを表現しにくい
2. **木構造**: 多対多の依存を表現できない
3. **有向グラフ**: 依存関係を自然に表現できる

有向グラフを選択する理由：
- 依存は本質的に二項関係（A が B に依存）であり、辺として表現できる
- 到達可能性（A から B へのパス）が「影響の伝播」に対応する
- グラフ理論の豊富なアルゴリズム（BFS、SCC 検出など）が利用可能

### 3.2 型付きラベル付き有向グラフ

リビジョン $r$ における設定状態を以下のように定義する：

$$
G_r = (V_r, E_r), \quad E_r \subseteq V_r \times V_r \times L
$$

- $V_r$: ノード集合。各ノードは設定要素（エンティティ、フィールド、フォームなど）を表す
- $E_r$: ラベル付き有向辺の集合。各辺は依存関係を表す
- $L$: ラベル集合。依存の種別を区別する

**なぜラベルが必要か**: 依存には複数の種別がある。「データを参照する」と「アクセス権を制御する」では、影響の伝播パターンが異なる。ラベルにより、依存の種別に応じた処理が可能になる。

### 3.3 辺の向き：provider → consumer

辺の向きには二つの選択肢がある：

1. **consumer → provider**: 「A は B に依存する」を A → B と表現
2. **provider → consumer**: 「A は B に依存する」を B → A と表現

Palimpsest では provider → consumer（選択肢 2）を採用する：

$$
(u \xrightarrow{l} v) \in E_r \iff \text{$v$ は $u$ に依存する}
$$

**理由**: 影響の伝播は「変更元から変更先へ」の方向に進む。provider → consumer の向きにすると、変更ノードから**順方向に辿る**だけで影響範囲が計算できる。逆向きだと、全ノードから逆方向に辿って「変更ノードに到達できるか」を調べる必要があり、$O(N)$ になる。

### 3.4 ラベル集合

$$
L = \{\texttt{uses}, \texttt{derives}, \texttt{controls}, \texttt{constrains}\}
$$

| ラベル | 意味 | 影響の性質 |
|-------|------|-----------|
| `uses` | データ依存 | 値が変わると再計算が必要 |
| `derives` | 構造的所有 | 親が消えると子も無効 |
| `controls` | 振る舞い制御 | 権限変更は制御対象に影響 |
| `constrains` | 制約条件 | 制約変更は検証対象に影響 |

**なぜこの 4 種類か**: MVP として、ローコード SaaS で頻出する依存パターンをカバーする最小セット。`uses` と `derives` はデータフロー、`controls` と `constrains` は制御フローに対応する。将来の拡張で追加可能だが、まず最小セットで検証する。

---

## 4. Impact 計算：なぜ到達可能性か

### 4.1 影響範囲の定義

ノード $s$ が変更されたとき、影響を受けるノードの集合を求めたい。これを**到達可能性**として定義する：

$$
\text{Impact}(\{s\}) = \{v \in V \mid s \leadsto v\}
$$

ここで $s \leadsto v$ は $s$ から $v$ への有向パスの存在を表す。

**なぜ到達可能性か**: 依存は推移的である。A が B に依存し、B が C に依存するなら、A の変更は C にも影響する。この推移的閉包が到達可能性である。

### 4.2 Seeds の拡張

複数のノードが同時に変更される場合、Seeds 集合 $S$ から到達可能なノード全体が影響範囲となる：

$$
\text{Impact}(S) = \bigcup_{s \in S} \{v \in V \mid s \leadsto v\} = \{v \in V \mid \exists s \in S,\ s \leadsto v\}
$$

### 4.3 計算方法：BFS

到達可能性は幅優先探索（BFS）で計算できる。Seeds を始点として、順方向に辿れるすべてのノードを列挙する。

**アルゴリズム**:
1. Seeds をキューに入れる
2. キューからノードを取り出し、訪問済みでなければ訪問済みにする
3. そのノードの後続ノード（outgoing edges の先）をキューに入れる
4. キューが空になるまで繰り返す

### 4.4 計算量の分析

| 記号 | 定義 |
|------|------|
| $N$ | $\|V\|$（全ノード数） |
| $M$ | $\|E\|$（全辺数） |
| $K_V$ | $\|\text{Impact}(S)\|$（影響ノード数） |
| $K_E$ | 影響部分グラフ内の辺数 |
| $K$ | $K_V + K_E$ |

BFS の計算量は、訪問するノード数と辿る辺数に比例する：

$$
\text{Time: } O(K), \quad \text{Space: } O(K_V)
$$

**重要な点**: 計算量は**全体サイズ $N$ ではなく、影響範囲 $K$ に比例**する。多くの場合 $K \ll N$ であり、これが増分計算の利点である。

### 4.5 $O(K)$ が成り立つ条件

理論上の $O(K)$ を実装で達成するには、以下の条件が必要：

1. **Lazy Loading**: 訪問するノードの隣接リストのみをロード。訪問しないノードの情報は読まない
2. **効率的なインデックス**: ノード ID から隣接リストへの $O(1)$ アクセス
3. **キャッシュ**: 頻繁にアクセスされるノードをメモリに保持

逆に、以下の場合は $O(K)$ が成り立たない：
- 全ノードを事前にロードする必要がある場合
- 隣接リストの取得に $O(N)$ かかる場合

---

## 5. 証拠パス：なぜ説明可能性が必要か

### 5.1 動機

影響範囲がわかるだけでは不十分である。「フォーム X が影響を受ける」と言われても、**なぜ**影響を受けるのかがわからなければ、対処のしようがない。

### 5.2 証拠パスの定義

影響ノード $x \in \text{Impact}(S)$ に対して、Seed から $x$ への具体的なパスを提示する：

$$
\pi(s, x) = (s = v_0, v_1, \ldots, v_k = x)
$$

このパスが「なぜ $x$ が影響を受けるか」の証拠となる。

### 5.3 最短パスの選択

複数のパスが存在する場合、BFS は自然に最短パスを与える（BFS の性質として、最初に到達したパスが最短）。最短パスは説明として簡潔であり、因果関係を辿りやすい。

### 5.4 例

「小計フィールドを変更すると、請求書フォームが影響を受ける」

証拠パス：
```
field:subtotal → expr:calc_tax → field:tax → form:invoice
```

これにより、「小計の変更が消費税計算式に影響し、消費税フィールドが変わり、それを参照する請求書フォームが影響を受ける」という因果関係が明確になる。

---

## 6. Event Log：なぜログを Source of Truth にするか

### 6.1 v0.2 の問題

v0.2 では、各リビジョンのグラフ $G_r$ を直接永続化していた。これには以下の問題がある：

1. **ストレージ爆発**: リビジョンごとにグラフ全体を保存すると、リビジョン数に比例してストレージが増大する
2. **GC の困難**: どのリビジョンを削除してよいか判断できない。すべてのリビジョンが参照される可能性がある
3. **差分計算のコスト**: 二つのリビジョン間の差分を計算するには、両方のグラフをロードして比較する必要がある

### 6.2 Event Sourcing パターン

Event Sourcing [Fowler] は、状態を直接保存する代わりに、**状態を変化させたイベントの列**を保存するパターンである。

$$
\text{Source of Truth} = [e_0, e_1, \ldots, e_n]
$$

状態はイベント列から導出（replay）できる：

$$
G_r = \text{Replay}([e_0, \ldots, e_r])
$$

### 6.3 Event Log の利点

1. **ストレージ効率**: イベントは差分情報のみを含むため、状態全体より小さい
2. **GC が明確**: イベントは削除しない（監査要件）。状態のキャッシュは自由に破棄できる
3. **差分が不要**: イベント自体が差分情報を持つ。Seeds はイベントから直接抽出できる

### 6.4 Revision の再定義

リビジョンはログのオフセット（位置）として定義する：

$$
\text{rev} = \text{offset} \in \mathbb{N}
$$

これにより、リビジョン管理が単純なカウンタになる。

### 6.5 Projection

グラフ $G_r$ はログからの**射影（projection）**である。これはキャッシュとして扱い、必要に応じて破棄・再構築できる。

---

## 7. Seeds 抽出：なぜイベントから直接抽出するか

### 7.1 v0.2 の問題

v0.2 では、Seeds を二つのグラフの差分から計算していた：

$$
\Delta V = (V_{\text{current}} \setminus V_{\text{prev}}) \cup (V_{\text{prev}} \setminus V_{\text{current}}) \cup \{v \mid \text{attrs changed}\}
$$

これには両グラフのロードが必要であり、$O(N)$ のコストがかかる。

### 7.2 イベントからの直接抽出

Event Log を採用することで、イベント自体から Seeds を抽出できる：

$$
\text{Seeds}(e) = \begin{cases}
\{n\} & e = \texttt{NodeAdded}(n) \\
\{n\} & e = \texttt{NodeRemoved}(n) \\
\{n\} & e = \texttt{AttrUpdated}(n) \\
\{v\} & e = \texttt{EdgeAdded}(u, v, l),\ l \in \{\texttt{uses}, \texttt{derives}\} \\
\{u, v\} & e = \texttt{EdgeAdded}(u, v, l),\ l \in \{\texttt{controls}, \texttt{constrains}\}
\end{cases}
$$

### 7.3 なぜエッジイベントで両端を見る場合があるか

`uses` / `derives` ラベルでは、consumer 側（$v$）のみが Seeds になる。これは「provider が変わると consumer が影響を受ける」というデータフローの性質に基づく。

一方、`controls` / `constrains` ラベルでは、**両端**が Seeds になる。これは：
- `controls`: ロールがフォームを制御する関係では、「このロールが何を制御しているか」と「このフォームが誰に制御されているか」の両方が意味を持つ
- `constrains`: 制約がフィールドに課される関係でも同様

この区別により、依存の種別に応じた適切な影響分析が可能になる。

### 7.4 Impact Seeds と Validation Seeds の分離

| 種別 | 目的 | EdgeAdded の Seeds |
|------|------|-------------------|
| Impact Seeds | 影響範囲の計算 | ラベルに応じて $\{v\}$ or $\{u,v\}$ |
| Validation Seeds | 整合性チェック | 常に $\{u, v\}$ |

**なぜ分離するか**: Impact は「何が影響を受けるか」という情報提供であり、Validation は「コミットしてよいか」という判定である。これらを混同すると、「影響があるから禁止」という過度に保守的なポリシーになる。

---

## 8. 投機的計算

### 8.1 動機

ユーザーが設定を編集している間に、バックグラウンドで Impact / Validation を計算しておけば、保存時に結果を即座に提示できる。

### 8.2 定義

イベント $e$ の発生時に、バックグラウンドで以下を計算：

$$
\text{Speculative}(e) = \{\text{Impact}(e), \text{Validation}(e), \text{Evidence}(e)\}
$$

### 8.3 キャンセル戦略

連続した編集操作では、古い計算をキャンセルして新しい計算に資源を割り当てる：

$$
e_{t+1}\ \text{到着時に}\ \text{Cancel}(\text{Speculative}(e_t))
$$

**実装**: `context.Context` によるキャンセルトークン。計算ループ内で定期的にキャンセルをチェックする。

### 8.4 デバウンス

短時間に連続する編集（タイピング中など）では、すべてのイベントで計算を開始するのは無駄である。一定時間（例: 300ms）待って、最後のイベントに対してのみ計算を開始する。

---

## 9. 不変条件と Validation

### 9.1 参照整合性

任意のリビジョンで、参照は閉じていなければならない：

$$
\forall (u \to v) \in E_r : u \in V_r \land v \in V_r
$$

つまり、存在しないノードへの参照（dangling edge）があってはならない。

### 9.2 Validation の役割

Validation は、コミット前に不変条件をチェックするゲートである。不変条件に違反する変更は拒否する。

**重要**: Validation と Impact は異なる。Impact は「何が影響を受けるか」の情報提供であり、影響があること自体は禁止理由にならない。Validation は「不変条件に違反するか」の判定であり、違反があれば禁止する。

---

## 10. GC とスナップショット

### 10.1 Projection のキャッシュ管理

グラフ $G_r$ は Projection（導出されたキャッシュ）であり、破棄可能である。LRU（Least Recently Used）や TTL（Time To Live）でキャッシュを管理する。

### 10.2 スナップショット

古いリビジョンへのアクセスでは、最初から replay すると遅い。一定間隔でスナップショット（グラフの完全な状態）を保存し、そこからの差分 replay で復元する：

$$
G_r = \text{Replay}(\text{snap}(r_0), [e_{r_0+1}, \ldots, e_r])
$$

### 10.3 Log Compaction

監査要件に応じて、古いイベントを圧縮または Cold Storage に退避できる。ただし、監査目的のイベントは削除しない。

---

## 11. 制限事項と将来拡張

### 11.1 循環依存

業務ロジックは循環依存を含みうる（例: A が B を参照し、B が A を参照）。循環があると、強連結成分（SCC）全体が相互に影響し合い、増分計算の効果が薄れる。

**対策**:
- SCC サイズの監視: 閾値を超えたら警告
- 構造的制約: 循環を作りにくい設計を誘導
- 不動点計算: 必要なら収束まで繰り返し計算

### 11.2 動的依存

計算式の内容によって依存先が変わる場合がある（例: `IF(condition, field_a, field_b)` では condition の値によって依存先が変わる）。

**対策**: 静的に最大の依存集合を取る（over-approximation）。false positive（実際には影響しないのに影響ありと判定）は許容し、false negative（影響があるのに見逃す）は避ける。

### 11.3 マルチテナント

テナント間でイベントログとグラフは隔離される。テナント ID をすべてのデータにプレフィックスとして付与する。

---

## 12. ビジネス価値

### 12.1 Time-Travel Audit

「いつ誰が何をしたか」だけでなく、「その操作がどの依存パスを通じて障害に連鎖したか」を追跡できる。これにより、障害の根本原因分析が可能になる。

### 12.2 AI Simulation

AI が仮説イベントを Sandbox に差し込み、Impact / Validation を評価できる。これにより、「この変更を行うと何が壊れるか」を変更前にシミュレーションできる。

---

## 13. 参考文献

1. Mokhov, Mitchell, Peyton Jones. [Build Systems à la Carte: Theory and Practice](https://doi.org/10.1017/S0956796820000088). JFP 2020.
   - ビルドシステムの統一的形式化。本プロジェクトの理論的基盤。

2. Hammer et al. [Adapton: Composable, Demand-Driven Incremental Computation](https://doi.org/10.1145/2594291.2594324). PLDI 2014.
   - Demand-driven な増分計算のフレームワーク。

3. [rustc Incremental Compilation](https://rustc-dev-guide.rust-lang.org/queries/incremental-compilation-in-detail.html)
   - Red-green algorithm の実装例。

4. [Bazel Skyframe](https://bazel.build/reference/skyframe)
   - 産業規模での増分計算の実証。

5. [Buck2 DICE](https://buck2.build/docs/insights_and_knowledge/modern_dice/)
   - 現代的な増分計算エンジン。

6. Fowler. [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)
   - イベントログを Source of Truth とするパターン。

7. Cousot & Cousot. [Abstract Interpretation](https://doi.org/10.1145/512950.512973). POPL 1977.
   - 静的解析の理論的基盤。over-approximation の正当化。
