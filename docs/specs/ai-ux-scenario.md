# AI エージェント UX シナリオ

## 「保存 = 賭け」から「保存 = 確定」へ

---

## 0. 本文書の目的

本文書では、Palimpsest が目指す UX を具体的なシナリオで示す。抽象的な理論（charter, formal-model）がユーザー体験としてどう現れるかを明確にし、MVP の要件導出につなげる。

---

## 1. シナリオ概要

### 1.1 状況

売上計算ロジックに「地域別ランク」を追加したい。

### 1.2 なぜこのシナリオが重要か

これは「既存の計算式を変更する」典型的な Day 2 操作である。Day 2 の問題とは：

- 変更の影響範囲がわからない
- 壊れたとき原因がわからない
- だから変更が怖い

このシナリオで Palimpsest がこれらをどう解決するかを示す。

### 1.3 登場人物

| 役割 | 説明 |
|------|------|
| ユーザー | 情シス担当。非エンジニアだが責任は重い |
| AI | Palimpsest 内蔵エージェント |
| システム | Event Log + Graph + Impact/Validation |

---

## 2. ユーザーの依頼

> 「売上計算のロジックに『地域別ランク』を加味したい」

AI はこの自然言語を**イベント列**に変換する。

**ポイント**: Palimpsest の AI は「文章を返す」のではなく「イベント列を生成する」。イベント列は機械可読であり、そのまま適用可能で、監査ログにも残る。

---

## 3. AI の処理

### 3.1 仮説イベント生成

AI は Sandbox 上に仮想トランザクションを作成する：

$$
\begin{aligned}
e_1 &= \texttt{NodeAdded}(\text{rank\_field}, \texttt{Field}, \{\ldots\}) \\
e_2 &= \texttt{EdgeAdded}(\text{rank\_field}, \text{sales\_expr}, \texttt{uses}) \\
e_3 &= \texttt{AttrUpdated}(\text{sales\_expr}, \{\text{formula}: \ldots\}) \\
e_4 &= \texttt{TxMarker}(\text{tx-001})
\end{aligned}
$$

**なぜ Sandbox か**: 本番の Event Log を汚さずに「もし適用したら」をシミュレーションする。TransactionMarker により、一貫したプレビューを保証（途中状態を見せない）。

### 3.2 Projection

Sandbox 上でグラフ $G'$ を構築。必要部分のみ lazy load することで、大規模設定でも高速に動作する。

### 3.3 Impact 計算

Seeds をイベント列から抽出：

$$
S = \{\text{rank\_field}, \text{sales\_expr}\}
$$

BFS で到達可能性を計算：

$$
\text{Impact}(S) = \{\text{sales\_expr}, \text{report\_A}, \text{report\_B}, \text{report\_C}, \ldots\}
$$

証拠パスも生成（「なぜ影響を受けるか」の説明）：

$$
\pi = \text{sales\_expr} \to \text{monthly\_total} \to \text{report\_A}
$$

### 3.4 Validation

不変条件をチェック：

- Dangling edge なし（参照整合性）
- 必須制約違反なし
- SCC 閾値内（循環依存の制限）

**Impact と Validation の違い**: Impact は「何が影響を受けるか」の情報提供。Validation は「コミットしてよいか」の判定。影響があること自体は禁止理由にならない。

### 3.5 修正案生成

影響を受けるノードに対して最小修正を提案：

$$
\begin{aligned}
e'_1 &= \texttt{AttrUpdated}(\text{report\_A\_expr}, \{\text{formula}: \ldots\}) \\
e'_2 &= \texttt{AttrUpdated}(\text{report\_B\_expr}, \{\text{formula}: \ldots\}) \\
e'_3 &= \texttt{AttrUpdated}(\text{report\_C\_expr}, \{\text{formula}: \ldots\})
\end{aligned}
$$

**なぜイベント列で返すか**:
1. **そのまま適用可能**: ユーザーが承認すれば即座に適用できる
2. **監査可能**: AI が何を提案したかがログに残る
3. **再現可能**: 同じ入力に対して同じ出力を再生成できる

**限界**: 修正案は必ずしも完全ではない。複雑なビジネスロジックの修正はユーザーの判断が必要。AI はあくまで「提案」であり、最終判断はユーザーが行う。

---

## 4. AI の回答

ユーザーに対して以下のように提示する：

> その変更を行うと、**月次帳票 A / B / C** が壊れます。
>
> **理由**: 売上計算式の変更が帳票の集計式に伝播するためです。
>
> ```
> sales_expr → monthly_total → report_A
> ```
>
> **修正案**: 帳票側の式を以下のように更新すれば整合性が保てます。
>
> プレビューしますか？

### 提示要素（優先順）

| 優先度 | 要素 | 目的 |
|--------|------|------|
| 1 | 影響一覧（重大度付き） | 何が壊れるかを知る |
| 2 | 影響理由（証拠パス） | なぜ壊れるかを理解する |
| 3 | 修正案（イベント列） | どう直せばいいかを知る |
| 4 | プレビュー | 適用後の状態を確認する |

---

## 5. 体験の反転

### Before（既存 SaaS）

```
変更 → 保存 → 祈る → 障害発覚 → 原因調査 → 修正
```

障害が起きてから原因を調べる。調べても「なぜ壊れたか」がわからないことが多い。

### After（Palimpsest）

```
変更 → 影響確認 → 修正案適用 → 保存（確定）
```

保存前に：
- 破壊的変更が**見えている**
- 修正案が**同時に出る**
- 因果が**記録される**

**核心**: 「保存 = 賭け」から「保存 = 確定」への体験反転。

---

## 6. MVP 必須コンポーネント

このシナリオを成立させるために必要なコンポーネント：

| コンポーネント | 役割 | 現状 |
|--------------|------|------|
| Event Log | 6 イベント + TxMarker | PoC 実装済 |
| Projection | ログ → グラフ構築 | PoC 実装済 |
| Impact | $\text{Reach}(S)$ + 証拠パス | PoC 実装済 |
| Validation | Dangling + 必須制約 | PoC 実装済（dangling のみ） |
| Sandbox | 仮説イベント適用 | 未実装 |
| Repair Plan | 影響先の修正案生成 | 未実装 |

---

## 7. 価値命題

> ローコードは「作れる」だけでは価値にならない。
> **運用で変え続けられること**が価値になる。

Palimpsest は変更を「儀式」から「科学」に変える：

| 手段 | 効果 |
|------|------|
| **ログ**で因果を追跡 | 「なぜ壊れたか」を遡れる |
| **グラフ**で構造を可視化 | 「何が影響を受けるか」がわかる |
| **計算**で未来を予測 | 「保存したらどうなるか」を事前に知る |

AI は「気の利いた文章を返す存在」ではなく、**変更の共同責任者**になる。
